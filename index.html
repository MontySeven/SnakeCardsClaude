<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Flash 2.0</title>
    <style>
        :root {
            --primary-color: #4CAF50;
            --secondary-color: #FF9800;
            --tertiary-color: #2196F3;
            --danger-color: #F44336;
            --light-color: #FFFFFF;
            --dark-color: #333333;
            --border-radius: 10px;
            --font-family: 'Comic Sans MS', cursive, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: var(--font-family);
        }

        body {
            background-color: #f0f8ff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* Header Styles */
        header {
            background-color: var(--primary-color);
            color: var(--light-color);
            width: 100%;
            text-align: center;
            padding: 15px;
            border-bottom: 5px solid var(--secondary-color);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        /* Container Styles */
        .container {
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
        }

        /* Flashcard Styles */
        .flashcard-container {
            background-color: var(--light-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
            margin-bottom: 20px;
            min-height: 300px;
        }

        .flashcard {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
        }

        .word {
            font-size: 3em;
            font-weight: bold;
            margin: 20px 0;
            color: var(--tertiary-color);
        }

        .prompt {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: var(--dark-color);
        }

        .feedback {
            font-size: 1.5em;
            margin: 20px 0;
            font-weight: bold;
        }

        .positive {
            color: var(--primary-color);
        }

        .negative {
            color: var(--danger-color);
        }

        /* Button Styles */
        .btn {
            padding: 12px 24px;
            font-size: 1.2em;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            margin: 10px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: var(--light-color);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: var(--light-color);
        }

        .btn-tertiary {
            background-color: var(--tertiary-color);
            color: var(--light-color);
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: var(--light-color);
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 1em;
        }

        .btn:hover {
            opacity: 0.9;
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Game Canvas Styles */
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }

        canvas {
            border: 5px solid var(--primary-color);
            border-radius: var(--border-radius);
            background-color: #f8f8f8;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            touch-action: none;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-top: 10px;
            font-size: 1.2em;
            color: var(--dark-color);
        }

        .game-controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        /* Admin Portal Styles */
        .admin-portal {
            background-color: var(--light-color);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            margin-top: 20px;
        }

        .admin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .admin-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--secondary-color);
        }

        .admin-tab {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #e9e9e9;
            border-top-left-radius: 5px;
            border-top-right-radius: 5px;
            margin-right: 5px;
        }

        .admin-tab.active {
            background-color: var(--secondary-color);
            color: var(--light-color);
        }

        .admin-content {
            padding: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        table, th, td {
            border: 1px solid #ddd;
        }

        th, td {
            padding: 10px;
            text-align: left;
        }

        th {
            background-color: var(--tertiary-color);
            color: var(--light-color);
        }

        tr:nth-child(even) {
            background-color: #f2f2f2;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .form-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1em;
        }

        .hidden {
            display: none;
        }

        .visible {
            display: block;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .modal-content {
            background-color: var(--light-color);
            padding: 20px;
            border-radius: var(--border-radius);
            width: 80%;
            max-width: 500px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close {
            cursor: pointer;
            font-size: 1.5em;
        }

        /* Responsive Styles */
        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .word {
                font-size: 2.5em;
            }

            .prompt, .feedback {
                font-size: 1.2em;
            }

            .btn {
                padding: 10px 20px;
                font-size: 1.1em;
            }

            canvas {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Snake Flash 2.0</h1>
        <button id="admin-toggle" class="btn btn-tertiary btn-small">Admin Mode</button>
    </header>

    <div class="container">
        <!-- Flashcard Component -->
        <div id="flashcard-section" class="flashcard-container">
            <div class="flashcard">
                <h2 class="prompt">Get ready to read!</h2>
                <div class="word">Hello</div>
                <div class="feedback"></div>
                <button id="read-btn" class="btn btn-primary">Read this word!</button>
                <button id="skip-btn" class="btn btn-secondary">Skip to Game</button>
            </div>
        </div>

        <!-- Game Component -->
        <div id="game-section" class="hidden">
            <div id="game-container">
                <canvas id="game-canvas" width="400" height="400"></canvas>
                <div class="game-info">
                    <div>Score: <span id="current-score">0</span></div>
                    <div>High Score: <span id="high-score">0</span></div>
                    <div>Time: <span id="timer">120</span>s</div>
                </div>
                <div class="game-controls">
                    <button id="pause-btn" class="btn btn-secondary">Pause</button>
                    <button id="restart-btn" class="btn btn-primary">Restart</button>
                </div>
            </div>
        </div>

        <!-- Admin Portal -->
        <div id="admin-section" class="admin-portal hidden">
            <div class="admin-header">
                <h2>Admin Portal</h2>
                <button id="admin-close" class="btn btn-danger btn-small">Close Admin</button>
            </div>
            <div class="admin-tabs">
                <div class="admin-tab active" data-tab="words">Words</div>
                <div class="admin-tab" data-tab="settings">Settings</div>
            </div>
            <div class="admin-content">
                <!-- Words Tab -->
                <div id="words-tab" class="tab-content visible">
                    <div class="form-group">
                        <label for="new-word">Add New Word:</label>
                        <div style="display: flex;">
                            <input type="text" id="new-word" placeholder="Enter a sight word">
                            <button id="add-word-btn" class="btn btn-primary">Add</button>
                        </div>
                    </div>
                    <h3>Word List</h3>
                    <table id="word-table">
                        <thead>
                            <tr>
                                <th>Word</th>
                                <th>Correct</th>
                                <th>Wrong</th>
                                <th>Last Review</th>
                                <th>Next Review</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="word-list"></tbody>
                    </table>
                </div>
                <!-- Settings Tab -->
                <div id="settings-tab" class="tab-content hidden">
                    <div class="form-group">
                        <label for="kid-name">Child's Name:</label>
                        <input type="text" id="kid-name" placeholder="Enter child's name">
                    </div>
                    <div class="form-group">
                        <label for="cards-per-session">Cards Per Session:</label>
                        <input type="number" id="cards-per-session" min="1" max="10" value="3">
                    </div>
                    <div class="form-group">
                        <label for="game-duration">Game Duration (seconds):</label>
                        <input type="number" id="game-duration" min="30" max="300" value="120">
                    </div>
                    <button id="save-settings-btn" class="btn btn-primary">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Password Modal -->
    <div id="password-modal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Enter Admin Password</h2>
                <span class="close">&times;</span>
            </div>
            <div class="form-group">
                <input type="password" id="admin-password" placeholder="Enter password">
                <p id="password-error" style="color: red; display: none;">Incorrect password</p>
            </div>
            <button id="submit-password" class="btn btn-primary">Submit</button>
        </div>
    </div>

    <script>
        // ----------------- DATA MODELS AND UTILITIES -----------------
        
        // Word Model
        class Word {
            constructor(text) {
                this.text = text;
                this.correctCount = 0;
                this.wrongCount = 0;
                this.lastReviewed = null;
                this.nextReview = new Date().toISOString().split('T')[0]; // Today
                this.interval = 1; // Days until next review
                this.correctToday = 0; // Correct responses today
            }
        }

        // Settings Model
        class Settings {
            constructor() {
                this.childName = "Friend";
                this.cardsPerSession = 3;
                this.gameDuration = 120; // seconds
                this.adminPassword = "admin123"; // Default password
            }
        }

        // Game State
        class GameState {
            constructor() {
                this.currentCardIndex = 0;
                this.cardsForSession = [];
                this.attemptCount = 0;
                this.gameActive = false;
                this.gamePaused = false;
                this.gameScore = 0;
                this.gameHighScore = 0;
                this.gameTimeRemaining = 120;
                this.gameTimer = null;
            }
        }

        // ----------------- DATA PERSISTENCE -----------------
        
        // LocalStorage Utility
        const storage = {
            saveWords: function(words) {
                localStorage.setItem('snakeFlashWords', JSON.stringify(words));
            },
            
            loadWords: function() {
                const words = localStorage.getItem('snakeFlashWords');
                if (words) {
                    return JSON.parse(words);
                }
                return this.getDefaultWords();
            },
            
            saveSettings: function(settings) {
                localStorage.setItem('snakeFlashSettings', JSON.stringify(settings));
            },
            
            loadSettings: function() {
                const settings = localStorage.getItem('snakeFlashSettings');
                if (settings) {
                    return JSON.parse(settings);
                }
                return new Settings();
            },
            
            saveHighScore: function(score) {
                localStorage.setItem('snakeFlashHighScore', score.toString());
            },
            
            loadHighScore: function() {
                const score = localStorage.getItem('snakeFlashHighScore');
                return score ? parseInt(score) : 0;
            },
            
            // Default 120 sight words
            getDefaultWords: function() {
                const sightWords = [
                    "a", "and", "away", "big", "blue", "can", "come", "down", "find", "for", 
                    "funny", "go", "help", "here", "I", "in", "is", "it", "jump", "little", 
                    "look", "make", "me", "my", "not", "one", "play", "red", "run", "said", 
                    "see", "the", "three", "to", "two", "up", "we", "where", "yellow", "you",
                    "all", "am", "are", "at", "ate", "be", "black", "brown", "but", "came", 
                    "did", "do", "eat", "four", "get", "good", "have", "he", "into", "like", 
                    "must", "new", "no", "now", "on", "our", "out", "please", "pretty", "ran", 
                    "ride", "saw", "say", "she", "so", "soon", "that", "there", "they", "this", 
                    "too", "under", "want", "was", "well", "went", "what", "white", "who", "will", 
                    "with", "yes", "after", "again", "an", "any", "as", "ask", "by", "could", 
                    "every", "fly", "from", "give", "giving", "had", "has", "her", "him", "his", 
                    "how", "just", "know", "let", "live", "may", "of", "old", "once", "open", 
                    "over", "put", "round", "some", "stop", "take", "thank", "them", "then", "think"
                ];
                
                return sightWords.map(word => new Word(word));
            }
        };

        // ----------------- SPEECH RECOGNITION -----------------
        
        // Speech Recognition Utility
        const speechRecognition = {
            recognition: null,
            
            init: function() {
                if ('webkitSpeechRecognition' in window) {
                    this.recognition = new webkitSpeechRecognition();
                } else if ('SpeechRecognition' in window) {
                    this.recognition = new SpeechRecognition();
                } else {
                    alert("Speech recognition is not supported in your browser. Please use Chrome, Edge, or Safari.");
                    return false;
                }
                
                this.recognition.continuous = false;
                this.recognition.interimResults = false;
                this.recognition.lang = 'en-US';
                
                return true;
            },
            
            start: function(onResultCallback, onErrorCallback) {
                if (!this.recognition) {
                    if (!this.init()) {
                        if (onErrorCallback) onErrorCallback("Speech recognition not supported");
                        return;
                    }
                }
                
                this.recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript.toLowerCase().trim();
                    if (onResultCallback) onResultCallback(transcript);
                };
                
                this.recognition.onerror = (event) => {
                    if (onErrorCallback) onErrorCallback(event.error);
                };
                
                this.recognition.start();
            },
            
            stop: function() {
                if (this.recognition) {
                    this.recognition.stop();
                }
            },
            
            // Compare spoken word to expected word with fuzzy matching
            compareWords: function(spoken, expected, threshold = 0.7) {
                // Very simple comparison for young children - strip whitespace and compare
                spoken = spoken.toLowerCase().trim();
                expected = expected.toLowerCase().trim();
                
                if (spoken === expected) return 1.0;
                
                // Check if the expected word is contained in the spoken phrase
                if (spoken.includes(expected)) return 0.9;
                
                // Calculate similarity using Levenshtein distance
                const distance = this.levenshteinDistance(spoken, expected);
                const maxLength = Math.max(spoken.length, expected.length);
                const similarity = 1 - distance / maxLength;
                
                return similarity;
            },
            
            // Levenshtein distance algorithm for comparing word similarity
            levenshteinDistance: function(a, b) {
                if (a.length === 0) return b.length;
                if (b.length === 0) return a.length;
                
                const matrix = [];
                
                // Initialize matrix
                for (let i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                }
                
                // Fill matrix
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i-1) === a.charAt(j-1)) {
                            matrix[i][j] = matrix[i-1][j-1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i-1][j-1] + 1, // substitution
                                matrix[i][j-1] + 1,   // insertion
                                matrix[i-1][j] + 1    // deletion
                            );
                        }
                    }
                }
                
                return matrix[b.length][a.length];
            }
        };

        // ----------------- SPACED REPETITION LOGIC -----------------
        
        // Spaced Repetition System
        const srs = {
            words: [],
            
            init: function() {
                this.words = storage.loadWords();
            },
            
            getWordsForReview: function(count) {
                const today = new Date().toISOString().split('T')[0];
                
                // Filter words due for review today
                let dueWords = this.words.filter(word => 
                    word.nextReview <= today
                );
                
                // If not enough words due, add some from the pool
                if (dueWords.length < count) {
                    const additionalWords = this.words
                        .filter(word => !dueWords.includes(word))
                        .sort((a, b) => {
                            // Prioritize words with earlier next review dates
                            return new Date(a.nextReview) - new Date(b.nextReview);
                        })
                        .slice(0, count - dueWords.length);
                    
                    dueWords = [...dueWords, ...additionalWords];
                }
                
                return dueWords.slice(0, count);
            },
            
            updateWordStatus: function(word, isCorrect) {
                const wordObj = this.words.find(w => w.text === word.text);
                if (!wordObj) return;
                
                const today = new Date().toISOString().split('T')[0];
                
                if (isCorrect) {
                    wordObj.correctCount++;
                    wordObj.correctToday = (wordObj.lastReviewed === today) 
                        ? wordObj.correctToday + 1 
                        : 1;
                } else {
                    wordObj.wrongCount++;
                    // Reset interval if wrong
                    wordObj.interval = 1;
                }
                
                wordObj.lastReviewed = today;
                
                // Update next review date based on spaced repetition algorithm
                if (isCorrect) {
                    if (wordObj.correctToday >= 2) {
                        // If correct twice in a day, advance to next interval
                        wordObj.interval = (wordObj.lastReviewed !== today) 
                            ? wordObj.interval * 2 
                            : wordObj.interval;
                            
                        const nextDate = new Date();
                        nextDate.setDate(nextDate.getDate() + wordObj.interval);
                        wordObj.nextReview = nextDate.toISOString().split('T')[0];
                    }
                } else {
                    // If wrong, review again today
                    wordObj.nextReview = today;
                }
                
                storage.saveWords(this.words);
            },
            
            addWord: function(text) {
                if (!text || text.trim() === '') return false;
                
                // Check if word already exists
                const exists = this.words.some(word => 
                    word.text.toLowerCase() === text.toLowerCase()
                );
                
                if (exists) return false;
                
                this.words.push(new Word(text.trim()));
                storage.saveWords(this.words);
                return true;
            },
            
            removeWord: function(text) {
                const initialLength = this.words.length;
                this.words = this.words.filter(word => word.text !== text);
                
                if (this.words.length !== initialLength) {
                    storage.saveWords(this.words);
                    return true;
                }
                return false;
            }
        };

        // ----------------- SNAKE GAME -----------------
        
        // Snake Game
        class SnakeGame {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // Game objects
                this.snake = {
                    body: [{ x: 10, y: 10 }],
                    size: 15,
                    color: '#4CAF50',
                    direction: { x: 0, y: 0 },
                    speed: 5,
                    growth: 2
                };
                
                this.enemySnakes = [];
                this.food = { x: 0, y: 0, size: 10, color: '#FF9800' };
                
                // Game state
                this.score = 0;
                this.highScore = storage.loadHighScore();
                this.gameOver = false;
                this.isPaused = false;
                this.lastFrameTime = 0;
                this.spawnTimer = 0;
                
                // Initialize
                this.bindEvents();
                this.resetFood();
                this.updateScoreDisplay();
            }
            
            bindEvents() {
                // Keyboard events
                document.addEventListener('keydown', (e) => {
                    if (this.gameOver || this.isPaused) return;
                    
                    switch (e.key) {
                        case 'ArrowUp':
                            if (this.snake.direction.y !== 1) {
                                this.snake.direction = { x: 0, y: -1 };
                            }
                            break;
                        case 'ArrowDown':
                            if (this.snake.direction.y !== -1) {
                                this.snake.direction = { x: 0, y: 1 };
                            }
                            break;
                        case 'ArrowLeft':
                            if (this.snake.direction.x !== 1) {
                                this.snake.direction = { x: -1, y: 0 };
                            }
                            break;
                        case 'ArrowRight':
                            if (this.snake.direction.x !== -1) {
                                this.snake.direction = { x: 1, y: 0 };
                            }
                            break;
                    }
                });
                
                // Touch events for mobile
                let touchStartX = 0;
                let touchStartY = 0;
                
                this.canvas.addEventListener('touchstart', (e) => {
                    if (this.gameOver || this.isPaused) return;
                    
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    e.preventDefault();
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    if (this.gameOver || this.isPaused) return;
                    e.preventDefault();
                });
                
                this.canvas.addEventListener('touchend', (e) => {
                    if (this.gameOver || this.isPaused) return;
                    
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;
                    
                    // Determine swipe direction
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // Horizontal swipe
                        if (deltaX > 0 && this.snake.direction.x !== -1) {
                            // Right swipe
                            this.snake.direction = { x: 1, y: 0 };
                        } else if (deltaX < 0 && this.snake.direction.x !== 1) {
                            // Left swipe
                            this.snake.direction = { x: -1, y: 0 };
                        }
                    } else {
                        // Vertical swipe
                        if (deltaY > 0 && this.snake.direction.y !== -1) {
                            // Down swipe
                            this.snake.direction = { x: 0, y: 1 };
                        } else if (deltaY < 0 && this.snake.direction.y !== 1) {
                            // Up swipe
                            this.snake.direction = { x: 0, y: -1 };
                        }
                    }
                    
                    e.preventDefault();
                });
            }
            
            start() {
                this.gameOver = false;
                this.isPaused = false;
                this.score = 0;
                
                // Reset snake
                this.snake.body = [{ x: this.width / 2, y: this.height / 2 }];
                this.snake.direction = { x: 1, y: 0 };
                
                // Clear enemy snakes
                this.enemySnakes = [];
                
                // Reset food
                this.resetFood();
                
                // Update display
                this.updateScoreDisplay();
                
                // Start game loop
                requestAnimationFrame(this.gameLoop.bind(this));
            }
            
            pause() {
                this.isPaused = !this.isPaused;
                
                if (!this.isPaused) {
                    requestAnimationFrame(this.gameLoop.bind(this));
                }
                
                return this.isPaused;
            }
            
            stop() {
                this.gameOver = true;
                
                // Update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    storage.saveHighScore(this.highScore);
                    this.updateScoreDisplay();
                }
            }
            
            resetFood() {
                // Generate random position for food
                let newX, newY;
                let validPosition = false;
                
                while (!validPosition) {
                    // Keep food away from edges
                    newX = Math.floor(Math.random() * (this.width - 40)) + 20;
                    newY = Math.floor(Math.random() * (this.height - 40)) + 20;
                    
                    // Check collision with snake
                    validPosition = true;
                    for (const segment of this.snake.body) {
                        const distance = Math.sqrt(
                            Math.pow(segment.x - newX, 2) + 
                            Math.pow(segment.y - newY, 2)
                        );
                        
                        if (distance < this.snake.size + this.food.size) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    // Check collision with enemy snakes
                    for (const enemy of this.enemySnakes) {
                        for (const segment of enemy.body) {
                            const distance = Math.sqrt(
                                Math.pow(segment.x - newX, 2) + 
                                Math.pow(segment.y - newY, 2)
                            );
                            
                            if (distance < enemy.size + this.food.size) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                }
                
                this.food.x = newX;
                this.food.y = newY;
            }
            
            spawnEnemySnake() {
                // Don't spawn too many enemies
                if (this.enemySnakes.length >= 3) return;
                
                // Determine spawn position on edge
                const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
                let x, y, direction;
                
                switch (side) {
                    case 0: // Top
                        x = Math.random() * this.width;
                        y = 0;
                        direction = { x: 0, y: 1 };
                        break;
                    case 1: // Right
                        x = this.width;
                        y = Math.random() * this.height;
                        direction = { x: -1, y: 0 };
                        break;
                    case 2: // Bottom
                        x = Math.random() * this.width;
                        y = this.height;
                        direction = { x: 0, y: -1 };
                        break;
                    case 3: // Left
                        x = 0;
                        y = Math.random() * this.height;
                        direction = { x: 1, y: 0 };
                        break;
                }
                
                // Create enemy snake
                const enemySnake = {
                    body: [{ x, y }],
                    size: 12, // Slightly smaller than player
                    color: '#F44336', // Enemy color
                    direction,
                    speed: this.snake.speed * 0.8, // Slower than player
                    growth: 1,
                    timeSinceLastMove: 0
                };
                
                this.enemySnakes.push(enemySnake);
            }
            
            updateEnemySnakes(deltaTime) {
                for (let i = 0; i < this.enemySnakes.length; i++) {
                    const enemy = this.enemySnakes[i];
                    
                    // Update enemy movement timer
                    enemy.timeSinceLastMove += deltaTime;
                    
                    // Move enemy when timer exceeds threshold based on speed
                    if (enemy.timeSinceLastMove > (1000 / enemy.speed)) {
                        enemy.timeSinceLastMove = 0;
                        
                        // Simple AI: occasionally change direction to move toward food
                        if (Math.random() < 0.05) {
                            // Determine direction to food
                            const dx = this.food.x - enemy.body[0].x;
                            const dy = this.food.y - enemy.body[0].y;
                            
                            if (Math.abs(dx) > Math.abs(dy)) {
                                enemy.direction = { 
                                    x: dx > 0 ? 1 : -1, 
                                    y: 0 
                                };
                            } else {
                                enemy.direction = { 
                                    x: 0, 
                                    y: dy > 0 ? 1 : -1 
                                };
                            }
                        }
                        
                        // Calculate new head position
                        const head = { ...enemy.body[0] };
                        head.x += enemy.direction.x * enemy.size;
                        head.y += enemy.direction.y * enemy.size;
                        
                        // Bounce off walls
                        if (head.x < 0 || head.x > this.width || 
                            head.y < 0 || head.y > this.height) {
                            
                            // Reverse direction
                            if (head.x < 0 || head.x > this.width) {
                                enemy.direction.x *= -1;
                            }
                            if (head.y < 0 || head.y > this.height) {
                                enemy.direction.y *= -1;
                            }
                            
                            // Recalculate head position
                            head.x = enemy.body[0].x + enemy.direction.x * enemy.size;
                            head.y = enemy.body[0].y + enemy.direction.y * enemy.size;
                        }
                        
                        // Add new head
                        enemy.body.unshift(head);
                        
                        // Check for food collision
                        const distance = Math.sqrt(
                            Math.pow(head.x - this.food.x, 2) + 
                            Math.pow(head.y - this.food.y, 2)
                        );
                        
                        if (distance < enemy.size + this.food.size) {
                            // Grow enemy snake
                            for (let j = 0; j < enemy.growth; j++) {
                                enemy.body.push({ ...enemy.body[enemy.body.length - 1] });
                            }
                            
                            // Generate new food
                            this.resetFood();
                        } else if (enemy.body.length > 5) {
                            // Remove tail if not growing
                            enemy.body.pop();
                        }
                    }
                }
                
                // Check for collisions with other snakes or walls
                for (let i = this.enemySnakes.length - 1; i >= 0; i--) {
                    const enemy = this.enemySnakes[i];
                    const head = enemy.body[0];
                    
                    // Check collision with player snake
                    for (const segment of this.snake.body) {
                        const distance = Math.sqrt(
                            Math.pow(head.x - segment.x, 2) + 
                            Math.pow(head.y - segment.y, 2)
                        );
                        
                        // If player is bigger, remove enemy
                        if (distance < enemy.size + this.snake.size && 
                            this.snake.body.length > enemy.body.length) {
                            this.enemySnakes.splice(i, 1);
                            this.score += 5; // Bonus points for defeating enemy
                            this.updateScoreDisplay();
                            break;
                        }
                    }
                }
            }
            
            updateScoreDisplay() {
                document.getElementById('current-score').textContent = this.score;
                document.getElementById('high-score').textContent = this.highScore;
            }
            
            gameLoop(timestamp) {
                if (this.gameOver || this.isPaused) return;
                
                // Calculate time since last frame
                const deltaTime = timestamp - this.lastFrameTime;
                this.lastFrameTime = timestamp;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Move snake based on time elapsed
                if (this.snake.direction.x !== 0 || this.snake.direction.y !== 0) {
                    const moveThreshold = 1000 / this.snake.speed;
                    
                    if (deltaTime > moveThreshold) {
                        // Calculate new head position
                        const head = { ...this.snake.body[0] };
                        head.x += this.snake.direction.x * this.snake.size;
                        head.y += this.snake.direction.y * this.snake.size;
                        
                        // Bounce off walls
                        if (head.x < 0 || head.x > this.width) {
                            head.x = Math.max(0, Math.min(this.width, head.x));
                            this.snake.direction.x *= -1;
                        }
                        
                        if (head.y < 0 || head.y > this.height) {
                            head.y = Math.max(0, Math.min(this.height, head.y));
                            this.snake.direction.y *= -1;
                        }
                        
                        // Check self-collision (game over)
                        for (let i = 1; i < this.snake.body.length; i++) {
                            const segment = this.snake.body[i];
                            const distance = Math.sqrt(
                                Math.pow(head.x - segment.x, 2) + 
                                Math.pow(head.y - segment.y, 2)
                            );
                            
                            if (distance < this.snake.size) {
                                this.stop();
                                return;
                            }
                        }
                        
                        // Check enemy collision
                        for (const enemy of this.enemySnakes) {
                            for (const segment of enemy.body) {
                                const distance = Math.sqrt(
                                    Math.pow(head.x - segment.x, 2) + 
                                    Math.pow(head.y - segment.y, 2)
                                );
                                
                                if (distance < this.snake.size + enemy.size) {
                                    // Only die if enemy is bigger
                                    if (enemy.body.length >= this.snake.body.length) {
                                        this.stop();
                                        return;
                                    }
                                }
                            }
                        }
                        
                        // Check food collision
                        const distanceToFood = Math.sqrt(
                            Math.pow(head.x - this.food.x, 2) + 
                            Math.pow(head.y - this.food.y, 2)
                        );
                        
                        if (distanceToFood < this.snake.size + this.food.size) {
                            // Grow snake
                            for (let i = 0; i < this.snake.growth; i++) {
                                this.snake.body.push({ ...this.snake.body[this.snake.body.length - 1] });
                            }
                            
                            // Increase score
                            this.score++;
                            this.updateScoreDisplay();
                            
                            // Generate new food
                            this.resetFood();
                        }
                        
                        // Move snake
                        this.snake.body.unshift(head);
                        this.snake.body.pop();
                    }
                }
                
                // Update enemy snakes
                this.updateEnemySnakes(deltaTime);
                
                // Spawn enemies occasionally
                this.spawnTimer += deltaTime;
                if (this.spawnTimer > 5000) { // Every 5 seconds
                    this.spawnTimer = 0;
                    this.spawnEnemySnake();
                }
                
                // Draw food
                this.ctx.beginPath();
                this.ctx.arc(this.food.x, this.food.y, this.food.size, 0, Math.PI * 2);
                this.ctx.fillStyle = this.food.color;
                this.ctx.fill();
                
                // Draw snake
                for (let i = 0; i < this.snake.body.length; i++) {
                    const segment = this.snake.body[i];
                    
                    this.ctx.beginPath();
                    this.ctx.arc(segment.x, segment.y, this.snake.size, 0, Math.PI * 2);
                    
                    // Gradient color from head to tail
                    const hue = 120 - (i / this.snake.body.length) * 40;
                    this.ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                    this.ctx.fill();
                    
                    // Draw eyes for head
                    if (i === 0) {
                        // Left eye
                        this.ctx.beginPath();
                        const eyeOffsetX = this.snake.direction.x * 5;
                        const eyeOffsetY = this.snake.direction.y * 5;
                        
                        // Eye positions based on direction
                        let leftEyeX, leftEyeY, rightEyeX, rightEyeY;
                        
                        if (this.snake.direction.x !== 0) {
                            // Horizontal movement
                            leftEyeX = segment.x + eyeOffsetX;
                            leftEyeY = segment.y - 4;
                            rightEyeX = segment.x + eyeOffsetX;
                            rightEyeY = segment.y + 4;
                        } else {
                            // Vertical movement
                            leftEyeX = segment.x - 4;
                            leftEyeY = segment.y + eyeOffsetY;
                            rightEyeX = segment.x + 4;
                            rightEyeY = segment.y + eyeOffsetY;
                        }
                        
                        // Draw eyes
                        this.ctx.beginPath();
                        this.ctx.arc(leftEyeX, leftEyeY, 2, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'white';
                        this.ctx.fill();
                        
                        this.ctx.beginPath();
                        this.ctx.arc(rightEyeX, rightEyeY, 2, 0, Math.PI * 2);
                        this.ctx.fillStyle = 'white';
                        this.ctx.fill();
                    }
                }
                
                // Draw enemy snakes
                for (const enemy of this.enemySnakes) {
                    for (let i = 0; i < enemy.body.length; i++) {
                        const segment = enemy.body[i];
                        
                        this.ctx.beginPath();
                        this.ctx.arc(segment.x, segment.y, enemy.size, 0, Math.PI * 2);
                        
                        // Gradient color from head to tail (red-orange)
                        const hue = 0 + (i / enemy.body.length) * 40;
                        this.ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                        this.ctx.fill();
                        
                        // Draw eyes for head
                        if (i === 0) {
                            const eyeOffsetX = enemy.direction.x * 3;
                            const eyeOffsetY = enemy.direction.y * 3;
                            
                            let leftEyeX, leftEyeY, rightEyeX, rightEyeY;
                            
                            if (enemy.direction.x !== 0) {
                                // Horizontal movement
                                leftEyeX = segment.x + eyeOffsetX;
                                leftEyeY = segment.y - 3;
                                rightEyeX = segment.x + eyeOffsetX;
                                rightEyeY = segment.y + 3;
                            } else {
                                // Vertical movement
                                leftEyeX = segment.x - 3;
                                leftEyeY = segment.y + eyeOffsetY;
                                rightEyeX = segment.x + 3;
                                rightEyeY = segment.y + eyeOffsetY;
                            }
                            
                            // Draw eyes
                            this.ctx.beginPath();
                            this.ctx.arc(leftEyeX, leftEyeY, 1.5, 0, Math.PI * 2);
                            this.ctx.fillStyle = 'white';
                            this.ctx.fill();
                            
                            this.ctx.beginPath();
                            this.ctx.arc(rightEyeX, rightEyeY, 1.5, 0, Math.PI * 2);
                            this.ctx.fillStyle = 'white';
                            this.ctx.fill();
                        }
                    }
                }
                
                // Continue game loop
                requestAnimationFrame(this.gameLoop.bind(this));
            }
        }

        // ----------------- APPLICATION STATE -----------------
        
        // App Controller
        class FlashSnakeApp {
            constructor() {
                this.settings = storage.loadSettings();
                this.gameState = new GameState();
                this.game = null;
                
                // Initialize SRS system
                srs.init();
                
                // Initialize Speech Recognition
                speechRecognition.init();
                
                // Bind DOM elements
                this.bindElements();
                this.bindEvents();
                
                // Set game high score
                this.gameState.gameHighScore = storage.loadHighScore();
                document.getElementById('high-score').textContent = this.gameState.gameHighScore;
                
                // Initialize with flashcard section
                this.showFlashcardSection();
                this.startFlashcardSession();
            }
            
            bindElements() {
                // Sections
                this.flashcardSection = document.getElementById('flashcard-section');
                this.gameSection = document.getElementById('game-section');
                this.adminSection = document.getElementById('admin-section');
                
                // Flashcard elements
                this.wordElement = document.querySelector('.word');
                this.promptElement = document.querySelector('.prompt');
                this.feedbackElement = document.querySelector('.feedback');
                this.readBtn = document.getElementById('read-btn');
                this.skipBtn = document.getElementById('skip-btn');
                
                // Game elements
                this.gameCanvas = document.getElementById('game-canvas');
                this.scoreElement = document.getElementById('current-score');
                this.highScoreElement = document.getElementById('high-score');
                this.timerElement = document.getElementById('timer');
                this.pauseBtn = document.getElementById('pause-btn');
                this.restartBtn = document.getElementById('restart-btn');
                
                // Admin elements
                this.adminToggle = document.getElementById('admin-toggle');
                this.adminClose = document.getElementById('admin-close');
                this.adminTabs = document.querySelectorAll('.admin-tab');
                this.wordsTab = document.getElementById('words-tab');
                this.settingsTab = document.getElementById('settings-tab');
                this.wordTable = document.getElementById('word-list');
                this.newWordInput = document.getElementById('new-word');
                this.addWordBtn = document.getElementById('add-word-btn');
                this.kidNameInput = document.getElementById('kid-name');
                this.cardsPerSessionInput = document.getElementById('cards-per-session');
                this.gameDurationInput = document.getElementById('game-duration');
                this.saveSettingsBtn = document.getElementById('save-settings-btn');
                
                // Password modal
                this.passwordModal = document.getElementById('password-modal');
                this.passwordInput = document.getElementById('admin-password');
                this.passwordError = document.getElementById('password-error');
                this.submitPasswordBtn = document.getElementById('submit-password');
                this.closeModalBtn = document.querySelector('.close');
            }
            
            bindEvents() {
                // Flashcard events
                this.readBtn.addEventListener('click', () => this.startReading());
                this.skipBtn.addEventListener('click', () => this.skipToGame());
                
                // Game events
                this.pauseBtn.addEventListener('click', () => this.togglePauseGame());
                this.restartBtn.addEventListener('click', () => this.restartGame());
                
                // Admin events
                this.adminToggle.addEventListener('click', () => this.showPasswordModal());
                this.adminClose.addEventListener('click', () => this.hideAdminSection());
                this.adminTabs.forEach(tab => {
                    tab.addEventListener('click', () => this.switchAdminTab(tab.dataset.tab));
                });
                this.addWordBtn.addEventListener('click', () => this.addNewWord());
                this.saveSettingsBtn.addEventListener('click', () => this.saveSettings());
                
                // Password modal events
                this.submitPasswordBtn.addEventListener('click', () => this.verifyPassword());
                this.closeModalBtn.addEventListener('click', () => this.hidePasswordModal());
                this.passwordInput.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') this.verifyPassword();
                });
            }
            
            // ----------------- FLASHCARD METHODS -----------------
            
            showFlashcardSection() {
                this.flashcardSection.classList.remove('hidden');
                this.gameSection.classList.add('hidden');
                this.adminSection.classList.add('hidden');
            }
            
            startFlashcardSession() {
                // Get cards for this session
                this.gameState.cardsForSession = srs.getWordsForReview(this.settings.cardsPerSession);
                this.gameState.currentCardIndex = 0;
                this.gameState.attemptCount = 0;
                
                // Display first card
                this.showCurrentCard();
            }
            
            showCurrentCard() {
                if (this.gameState.currentCardIndex >= this.gameState.cardsForSession.length) {
                    // All cards done, start game
                    this.skipToGame();
                    return;
                }
                
                const currentWord = this.gameState.cardsForSession[this.gameState.currentCardIndex];
                this.wordElement.textContent = currentWord.text;
                this.promptElement.textContent = `Read this word, ${this.settings.childName}!`;
                this.feedbackElement.textContent = '';
                this.feedbackElement.className = 'feedback';
                this.readBtn.textContent = 'Read this word!';
                this.gameState.attemptCount = 0;
            }
            
            startReading() {
                this.readBtn.disabled = true;
                this.readBtn.textContent = 'Listening...';
                
                speechRecognition.start(
                    (transcript) => this.processReading(transcript),
                    (error) => this.handleSpeechError(error)
                );
            }
            
            processReading(transcript) {
                this.readBtn.disabled = false;
                this.readBtn.textContent = 'Read this word!';
                
                const currentWord = this.gameState.cardsForSession[this.gameState.currentCardIndex];
                const similarity = speechRecognition.compareWords(transcript, currentWord.text);
                
                if (similarity >= 0.7) {
                    // Correct answer
                    this.feedbackElement.textContent = `Good job, ${this.settings.childName}!`;
                    this.feedbackElement.className = 'feedback positive';
                    
                    // Update word status
                    srs.updateWordStatus(currentWord, true);
                    
                    // Move to next card after a short delay
                    setTimeout(() => {
                        this.gameState.currentCardIndex++;
                        this.showCurrentCard();
                    }, 1500);
                } else {
                    // Wrong answer
                    this.gameState.attemptCount++;
                    
                    if (this.gameState.attemptCount >= 3) {
                        // Too many attempts, move to next card
                        this.feedbackElement.textContent = `The word was "${currentWord.text}". Let's try another!`;
                        this.feedbackElement.className = 'feedback negative';
                        
                        // Update word status
                        srs.updateWordStatus(currentWord, false);
                        
                        // Move to next card after a short delay
                        setTimeout(() => {
                            this.gameState.currentCardIndex++;
                            this.showCurrentCard();
                        }, 2000);
                    } else {
                        // Still have attempts left
                        this.feedbackElement.textContent = `That's not right, try again! (Attempt ${this.gameState.attemptCount}/3)`;
                        this.feedbackElement.className = 'feedback negative';
                    }
                }
            }
            
            handleSpeechError(error) {
                this.readBtn.disabled = false;
                this.readBtn.textContent = 'Read this word!';
                
                if (error === 'no-speech') {
                    this.feedbackElement.textContent = "I didn't hear anything. Please try again!";
                } else if (error === 'not-allowed') {
                    this.feedbackElement.textContent = "Please allow microphone access to use this app.";
                } else {
                    this.feedbackElement.textContent = "There was a problem. Please try again!";
                }
                
                this.feedbackElement.className = 'feedback negative';
            }
            
            // ----------------- GAME METHODS -----------------
            
            skipToGame() {
                this.showGameSection();
                this.startGame();
            }
            
            showGameSection() {
                this.flashcardSection.classList.add('hidden');
                this.gameSection.classList.remove('hidden');
                this.adminSection.classList.add('hidden');
            }
            
            startGame() {
                // Initialize game timer
                this.gameState.gameTimeRemaining = this.settings.gameDuration;
                this.updateTimerDisplay();
                
                // Create game if not exists
                if (!this.game) {
                    this.game = new SnakeGame('game-canvas');
                }
                
                // Start game
                this.game.start();
                this.gameState.gameActive = true;
                this.gameState.gamePaused = false;
                
                // Start timer
                this.startGameTimer();
            }
            
            startGameTimer() {
                // Clear existing timer
                if (this.gameState.gameTimer) {
                    clearInterval(this.gameState.gameTimer);
                }
                
                // Set new timer
                this.gameState.gameTimer = setInterval(() => {
                    if (!this.gameState.gamePaused && this.gameState.gameActive) {
                        this.gameState.gameTimeRemaining--;
                        this.updateTimerDisplay();
                        
                        if (this.gameState.gameTimeRemaining <= 0) {
                            // Time's up, pause game and show flashcards
                            this.pauseGame();
                            setTimeout(() => {
                                this.showFlashcardSection();
                                this.startFlashcardSession();
                            }, 1000);
                        }
                    }
                }, 1000);
            }
            
            updateTimerDisplay() {
                this.timerElement.textContent = this.gameState.gameTimeRemaining;
            }
            
            togglePauseGame() {
                if (this.game) {
                    this.gameState.gamePaused = this.game.pause();
                    this.pauseBtn.textContent = this.gameState.gamePaused ? 'Resume' : 'Pause';
                }
            }
            
            pauseGame() {
                if (!this.gameState.gamePaused) {
                    this.togglePauseGame();
                }
            }
            
            restartGame() {
                // Reset timer
                this.gameState.gameTimeRemaining = this.settings.gameDuration;
                this.updateTimerDisplay();
                
                // Restart game
                if (this.game) {
                    this.game.start();
                    
                    // Reset pause button
                    this.gameState.gamePaused = false;
                    this.pauseBtn.textContent = 'Pause';
                    
                    // Restart timer
                    this.startGameTimer();
                }
            }
            
            // ----------------- ADMIN METHODS -----------------
            
            showPasswordModal() {
                this.passwordModal.classList.remove('hidden');
                this.passwordInput.focus();
                this.passwordError.style.display = 'none';
            }
            
            hidePasswordModal() {
                this.passwordModal.classList.add('hidden');
                this.passwordInput.value = '';
            }
            
            verifyPassword() {
                const password = this.passwordInput.value;
                
                if (password === this.settings.adminPassword) {
                    this.hidePasswordModal();
                    this.showAdminSection();
                } else {
                    this.passwordError.style.display = 'block';
                }
            }
            
            showAdminSection() {
                this.flashcardSection.classList.add('hidden');
                this.gameSection.classList.add('hidden');
                this.adminSection.classList.remove('hidden');
                
                // Pause game if running
                if (this.gameState.gameActive && !this.gameState.gamePaused) {
                    this.pauseGame();
                }
                
                // Initialize admin section
                this.switchAdminTab('words');
                this.updateWordTable();
                
                // Set current settings values
                this.kidNameInput.value = this.settings.childName;
                this.cardsPerSessionInput.value = this.settings.cardsPerSession;
                this.gameDurationInput.value = this.settings.gameDuration;
            }
            
            hideAdminSection() {
                this.adminSection.classList.add('hidden');
                
                // Return to previous section (game or flashcards)
                if (this.gameState.gameActive) {
                    this.showGameSection();
                } else {
                    this.showFlashcardSection();
                }
            }
            
            switchAdminTab(tabName) {
                // Update tab styles
                this.adminTabs.forEach(tab => {
                    if (tab.dataset.tab === tabName) {
                        tab.classList.add('active');
                    } else {
                        tab.classList.remove('active');
                    }
                });
                
                // Show selected tab content
                if (tabName === 'words') {
                    this.wordsTab.classList.remove('hidden');
                    this.settingsTab.classList.add('hidden');
                    this.updateWordTable();
                } else if (tabName === 'settings') {
                    this.wordsTab.classList.add('hidden');
                    this.settingsTab.classList.remove('hidden');
                }
            }
            
            updateWordTable() {
                this.wordTable.innerHTML = '';
                
                srs.words.forEach(word => {
                    const row = document.createElement('tr');
                    
                    // Format dates
                    const lastReviewed = word.lastReviewed ? new Date(word.lastReviewed).toLocaleDateString() : 'Never';
                    const nextReview = new Date(word.nextReview).toLocaleDateString();
                    
                    row.innerHTML = `
                        <td>${word.text}</td>
                        <td>${word.correctCount}</td>
                        <td>${word.wrongCount}</td>
                        <td>${lastReviewed}</td>
                        <td>${nextReview}</td>
                        <td>
                            <button class="btn btn-danger btn-small delete-word" data-word="${word.text}">Delete</button>
                        </td>
                    `;
                    
                    this.wordTable.appendChild(row);
                });
                
                // Add event listeners to delete buttons
                document.querySelectorAll('.delete-word').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const word = e.target.dataset.word;
                        this.deleteWord(word);
                    });
                });
            }
            
            addNewWord() {
                const wordText = this.newWordInput.value.trim();
                
                if (wordText) {
                    if (srs.addWord(wordText)) {
                        this.updateWordTable();
                        this.newWordInput.value = '';
                    } else {
                        alert('This word already exists!');
                    }
                }
            }
            
            deleteWord(wordText) {
                if (confirm(`Are you sure you want to delete "${wordText}"?`)) {
                    if (srs.removeWord(wordText)) {
                        this.updateWordTable();
                    }
                }
            }
            
            saveSettings() {
                const childName = this.kidNameInput.value.trim() || 'Friend';
                const cardsPerSession = parseInt(this.cardsPerSessionInput.value) || 3;
                const gameDuration = parseInt(this.gameDurationInput.value) || 120;
                
                this.settings.childName = childName;
                this.settings.cardsPerSession = Math.min(Math.max(cardsPerSession, 1), 10); // Limit between 1-10
                this.settings.gameDuration = Math.min(Math.max(gameDuration, 30), 300); // Limit between 30-300 seconds
                
                storage.saveSettings(this.settings);
                
                alert('Settings saved!');
            }
        }

        // ----------------- INITIALIZE APPLICATION -----------------
        
        // Start the application when the page is loaded
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const app = new FlashSnakeApp();
            } catch (error) {
                console.error('Failed to initialize application:', error);
                // Display a user-friendly error message
                const container = document.querySelector('.container');
                if (container) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px; background-color: #f8d7da; border-radius: 10px; margin-top: 20px;">
                            <h2>Oops! Something went wrong</h2>
                            <p>We encountered an error while starting the application. Please try refreshing the page.</p>
                            <button onclick="window.location.reload()" class="btn btn-primary">Refresh Page</button>
                        </div>
                    `;
                }
            }
        });
    </script>
</body>
</html>
